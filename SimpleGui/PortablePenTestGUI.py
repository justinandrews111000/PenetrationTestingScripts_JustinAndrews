"""
Script Name: PortablePenTestGUI.py
Author: Justin Andrews
Date: 10/15/2024
Version: 0.3

Description:
    A modular Python-based graphical user interface (GUI) application designed to manage 
    and execute penetration testing scripts. The application provides a centralized 
    dashboard for organizing, configuring, and running security testing scripts.

    Core Features:
    - Settings Management: Persistent application configuration using JSON storage
    - Script Organization: Dynamic loading of Python scripts from a user-specified directory
    - Blacklist/Whitelist: Built-in script filtering system to control which scripts are available
    - Modular Architecture: Separation of concerns through distinct manager classes
      * SettingsManager: Handles configuration persistence and script loading
      * ApplicationManager: Controls GUI element states and updates
      * WindowManager: Manages application windows and startup flow
      * ScriptWindow: Provides the main script selection interface
      * ScriptFunctions: Handles individual script execution and parameter parsing

    Interface Components:
    - First-time setup wizard for initial configuration
    - Grid-based dashboard displaying available scripts as buttons
    - Dynamic script windows for individual script configuration and execution
    - Automated parameter discovery from script content using "GUI Parameters" markers

    Technical Implementation:
    - JSON-based settings persistence
    - Path-based script management using pathlib
    - Event-driven GUI using tkinter
    - Proper encapsulation through class-based architecture
    - Support for script-specific parameter parsing and configuration

TODO: Code Improvement List
    1. Standardize naming conventions (use snake_case consistently)
    2. Reduce reliance on global variables (consider using a class structure)
    3. Remove redundant variable declarations
    4. Improve error handling (catch and handle potential exceptions)
    5. Enhance function naming for clarity (e.g., choose_source_directory() instead of get_directory())
    6. Add consistent commenting and docstrings for all functions
    7. Use type hinting consistently throughout the code
    8. Move hardcoded values to a configuration file or constants
    9. Improve GUI structure
    10. Remove or comment out debugging code (e.g., print_settings() function)
    11. Optimize file operations (minimize opening/closing of files)
    12. Display error messages in GUI dialogs instead of printing to console
    13. Remove unused imports and use specific imports instead of from tkinter import *
    14. Reorganize code to separate GUI setup, file operations, and business logic
    15. Complete implementation of TODO items and placeholder sections

Additional tasks:
    - Implement proper logging instead of print statements for debugging
    - Consider adding input validation for user inputs
    - Review and optimize performance, especially for file operations
    - Ensure all functions have appropriate return types specified
    - Add comments explaining complex logic or algorithms
    - Consider implementing a config parser for handling settings instead of manually implementing it
    - Review security implications, especially for file operations and user inputs
    - Implement proper cleanup of resources (e.g., closing files, destroying GUI elements) 

Dependencies:
- tkinter
- json
- pathlib
"""

from tkinter import *
from tkinter import ttk, filedialog
import json
from pathlib import Path


class SettingsManager:
    def __init__(self):
        self._first_start = True
        self._source_dir = ""
        self._settings_name = "applicationSettings.JSON"
        self._settings_path = Path(
            Path(__file__).parent.joinpath(Path(self._settings_name))
        )
        self._black_list_scripts = [
            Path(
                r"C:\Users\justi\PenetrationTestingScripts_JustinAndrews\MainScripts\Util.py"
            )
        ]
        self._white_list_scripts = []
        self._loaded_scripts = []
        self._current_settings_dict = {}
        self._default_settings_dict = {
            "first_start": True,
            "source_dir": "",
            "settings_name": "applicationSettings.JSON",
        }

        self.check_settings_initialized()
        self.load_settings()

    @property
    def first_start(self):
        return self._first_start

    @first_start.setter
    def first_start(self, value):
        self._first_start = bool(value)

    @property
    def source_dir(self):
        return self._source_dir

    @source_dir.setter
    def source_dir(self, value):
        self._source_dir = str(value)

    @property
    def settings_name(self):
        return self._settings_name

    @settings_name.setter
    def settings_name(self, value):
        self._settings_name = str(value)
        self._settings_path = Path(
            Path(__file__).parent.joinpath(Path(self._settings_name))
        )

    @property
    def settings_path(self):
        return self._settings_path

    @property
    def black_list_scripts(self):
        return self._black_list_scripts

    @black_list_scripts.setter
    def black_list_scripts(self, value):
        self._black_list_scripts = [Path(script) for script in value]

    @property
    def white_list_scripts(self):
        return self._white_list_scripts

    @white_list_scripts.setter
    def white_list_scripts(self, value):
        self._white_list_scripts = [Path(script) for script in value]

    @property
    def loaded_scripts(self):
        return self._loaded_scripts

    @loaded_scripts.setter
    def loaded_scripts(self, value):
        self._loaded_scripts = list(value)

    @property
    def current_settings_dict(self):
        return self._current_settings_dict

    @current_settings_dict.setter
    def current_settings_dict(self, value):
        self._current_settings_dict = dict(value)

    @property
    def default_settings_dict(self):
        return self._default_settings_dict

    @default_settings_dict.setter
    def default_settings_dict(self, value):
        self._default_settings_dict = dict(value)

    def check_settings_initialized(self):
        try:
            with self.settings_path.open("r", encoding="utf-8") as settings_json:
                self.current_settings_dict = json.load(settings_json)
        except FileNotFoundError:
            with self.settings_path.open("w", encoding="utf-8") as new_settings_file:
                json.dump(self.default_settings_dict, new_settings_file)

    # Fucntion to write to a JSON file. Used for saving settings for persistance.
    def write_json(self, var_name: str, var: object, new_value):
        """
        Write a variable to the settings JSON file and updates the variable in the
            settings_dict and global scope. Ensures the value given is the same
            type as the variable given.

                TODO:
                    -Refactor and split into to smaller components
                        -Write Function
                        -Update function
                    -Automatically pull the name from the locals() to reduce parameters and misinput.
                    -Return updated setting_dict

                Parameters:
                        var_name (str): Name of the variable in the JSON file. This is the same name as the global variable.
                        var (obj): Variable to update, should be the same as var_name.
                        new_value: The new value to be saved in the variable.
                        setting_file_path (Path): Path to the settings file.

                Returns:
                    None
        """

        # New and old variable types.
        var_type = type(var)
        new_var_type = type(new_value)

        # Check variable types and update if same.
        if var_type != new_var_type:
            print(
                f"{var_name} is a {var_type}\n",
                f"{new_value} is a {new_var_type}\n",
                "Not assigning new value to var. Ensure types are correct.",
            )
        else:
            self.current_settings_dict[var_name] = new_value
            var = new_value

            with self.settings_path.open("w", -1, "utf-8") as settings_json:
                json.dump(self.current_settings_dict, settings_json)
            self.load_settings()

    def load_settings(self):
        """
        Loads settings from a JSON file

        parameters:
            settings_dict (dict): The settings dictionary to hold settings key/value pairs.

        Returns:
            settings_dict (dict): Loaded settings.
        """

        with self.settings_path.open("r", encoding="utf-8") as settings_json:
            self.current_settings_dict = json.load(settings_json)

        for key, value in self.current_settings_dict.items():
            if hasattr(self, key):
                setattr(self, key, value)

    def debug_print_settings(self):
        print("Showing instance settings:")
        for key, value in self.current_settings_dict.items():
            print(f"{" " * 5}{key}:{value}")

        print(f"\n{"-" * 10}\n")
        with self.settings_path.open("r", encoding="utf-8") as json_file:
            json_dir = json.load(json_file)

        print("Showing json settings")
        for key, value in json_dir.items():
            print(f"{" " * 5}{key}:{value}")
        print(f"\n{"-" * 10}\n")

    def set_source_dir(self):
        """
        have a user choose a dictionary.

        parameters:
            None

        Returns:
            None
        """
        self.source_dir = filedialog.askdirectory()
        self.write_json("source_dir", self.source_dir, self.source_dir)

    def load_scripts(self):
        temp_script_list = []
        for file in Path(self.source_dir).glob("*.py"):
            temp_script_list.append(file)

        for file in temp_script_list:
            if file in self.black_list_scripts:
                temp_script_list.pop(temp_script_list.index(file))
            else:
                print(file)
        self.loaded_scripts = temp_script_list


class ApplicationManager:
    def __init__(self, root):
        self.root = root

    def disable_element(self, element_to_disable):
        print(f"{element_to_disable} has been disabled.")
        element_to_disable.config(state="disable")

    def enable_element(self, element_to_enable):
        print(f"{element_to_enable} has been enabled.")
        element_to_enable.config(state="enable")

    def update_text(self, element_to_update, new_text):
        print(f"{element_to_update} has been updated.")
        element_to_update.config(text=new_text)


class ButtonCommands:
    def __init__(self, app_man_inst, settings_man_inst):
        self.app_man_inst = app_man_inst
        self.settings_man_inst = settings_man_inst

    def startup_meth(self, element, new_text, element_to_enable):
        print("In startup method")
        self.settings_man_inst.set_source_dir()
        self.app_man_inst.update_text(element, new_text)
        self.app_man_inst.enable_element(element_to_enable)
        self.settings_man_inst.write_json(
            "first_start", self.settings_man_inst.first_start, False
        )


class FirstTimeStartWindow:

    def __init__(self, window_man, root):
        self._window_man = window_man
        self._root = root
        self.settings = SettingsManager()
        self.app = ApplicationManager(self._root)
        self.button_cmds = ButtonCommands(self.app, self.settings)
        self.startup_frame = None

    @property
    def window_man(self):
        return self._window_man

    @property
    def root(self):
        return self._root

    def start(self):

        self.settings.load_settings()

        dir_label_text = f"Selected Directory: {self.settings.source_dir}"
        self.startup_frame = ttk.Frame(self.root, padding=10)
        self.startup_frame.grid()
        ttk.Label(self.startup_frame, text="First Time Configuration").grid(
            column=1, row=0
        )
        ttk.Button(
            self.startup_frame,
            text="Select Source Folder",
            command=lambda: self.button_cmds.startup_meth(
                dir_label, dir_label_text, continue_button
            ),
        ).grid(column=1, row=1)
        dir_label = ttk.Label(self.startup_frame, text=dir_label_text)
        dir_label.grid(column=1, row=2)
        continue_button = ttk.Button(
            self.startup_frame,
            text="Continue",
            command=lambda: self.exit_startup(),
            state="disabled",
        )
        continue_button.grid(column=1, row=3)

        self.root.mainloop()

    def exit_startup(self):
        self.startup_frame.destroy()
        self.window_man.start_instance()


class ScriptWindow:

    def __init__(self, window_man, root):
        self._window_man = window_man
        self._root = root
        self.app = ApplicationManager(root)
        self.settings = SettingsManager()
        self.button_cmds = ButtonCommands(self.app, self.settings)
        self.script_frame = ttk.Frame(root, padding=10)
        self.button_frame = ttk.Frame(self.script_frame, padding=10)
        self.generate_script_buttons()

    @property
    def window_man(self):
        return self._window_man

    @property
    def root(self):
        return self._root

    class ScriptButton:
        def __init__(self, script, grid_loc, frame):
            self._script = script
            self._script_functions = ScriptFunctions(script)
            self._grid_loc = grid_loc
            self._frame = frame
            self._button = self._create_button()

        @property
        def script(self):
            return self._script

        @property
        def script_functions(self):
            return self._script_functions

        @property
        def grid_loc(self):
            return self._grid_loc

        @property
        def frame(self):
            return self._frame

        def _create_button(self):
            button = ttk.Button(
                self._frame, text=Path(self._script).name, command=self.script_run
            )
            button.grid(column=self._grid_loc[0], row=self._grid_loc[1])
            return button

        def script_run(self):
            script_root = Tk()
            script_frame = ttk.Frame(script_root, padding=10)
            script_frame.grid()
            ttk.Label(script_frame, text=self._script).grid(column=0, row=0)
            ttk.Button(
                script_frame,
                text="print script",
                command=lambda: self.script_functions.generate_settings(),
            ).grid(column=0, row=0)
            ttk.Button(script_frame, text="Quit", command=script_root.destroy).grid(
                column=0, row=1
            )
            script_root.mainloop()

    def generate_script_buttons(self):
        self.settings.load_scripts()
        scripts = self.settings.loaded_scripts

        # Define the number of columns you want in the grid
        num_columns = 3  # You can adjust this value as needed

        for index, script in enumerate(scripts):
            # Calculate grid position
            row = index // num_columns
            column = index % num_columns

            # Create ScriptButton instance
            self.ScriptButton(script, (column, row), self.button_frame)

        self.script_frame.update_idletasks()

    def start(self):

        self.script_frame.grid()
        self.button_frame.grid()

        ttk.Label(
            self.script_frame,
            text="Select a script to open another window to set it's options and run it.",
        ).grid(column=0, row=0)

        self.button_frame.grid(column=0, row=1)

        self.root.mainloop()

    def exit_window(self):
        self.script_frame.destroy()


class ScriptFunctions:
    def __init__(self, script):
        self._script = Path(script)

    @property
    def script(self):
        return self._script

    def generate_settings(self):

        script_settings_dict = {}

        with self.script.open("r", encoding="utf-8") as script:
            for line_num, line in enumerate(script, 1):
                print(f"[{line_num}] {line}")
                if line.startswith("GUI Parameters Start:"):
                    settings_start = line_num
                    print("Start found")
                if line.startswith("GUI Parameters End:"):
                    settings_end = line_num
                    print("End found")

            settings = range(settings_start, settings_end - 1)
            script.seek(0)
            content = script.readlines()

            print("Supposed range")
            for num in settings:
                print(num)
                print(len(content))
                line = content[num]
                print(f"[{num}] {line}")
                sep_index = line.rfind(":")
                key = line[0:sep_index]
                value = line[sep_index + 1 : -1]
                script_settings_dict[key] = value.strip()

        print("Dict:")
        for key, value in script_settings_dict.items():
            print(f"{key}:{value}")

        print(script_settings_dict)


class WindowManager:
    def __init__(self):

        self.settings = SettingsManager()
        self.root = Tk()

    def start_instance(self):
        self.settings.load_settings()
        if self.settings.first_start:
            print(self.settings.first_start)
            FirstTimeStartWindow(self, self.root).start()
        else:
            ScriptWindow(self, self.root).start()


WindowManager().start_instance()
